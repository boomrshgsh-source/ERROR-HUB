local WEBHOOK_URL = "https://canary.discord.com/api/webhooks/1440700806495080511/GX8AAGu3VXobKS3I_tRMStwY027E4d6rJoNNKKX4tK7ozjIW7wyGVAdKU1l1zAW-FtY4"

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Marketplace = game:GetService("MarketplaceService")
local UserInputService = game:GetService("UserInputService")

local plr = Players.LocalPlayer

local function GetOS()
    local platform = UserInputService:GetPlatform()
    if platform == Enum.Platform.Windows then
        return "Windows üíª"
    elseif platform == Enum.Platform.IOS then
        return "iOS üçé"
    elseif platform == Enum.Platform.Android then
        return "Android ü§ñ"
    else
        return "Unknown"
    end
end
local OS = GetOS()

local executorName, executorVersion = "Unknown", ""
pcall(function()
    if identifyexecutor then
        local n, v = identifyexecutor()
        executorName = n or "Unknown"
        executorVersion = v or ""
    end
end)
local ExecutorText = executorName
if executorVersion ~= "" then
    ExecutorText = ExecutorText .. " | " .. executorVersion
end

local avatarApi = "https://thumbnails.roblox.com/v1/users/avatar?userIds=" ..
    plr.UserId .. "&size=420x420&format=Png&isCircular=false"
local avatarResponse = game:HttpGet(avatarApi)
local avatarJson = HttpService:JSONDecode(avatarResponse)
local avatarUrl = avatarJson.data[1].imageUrl or ""

local mapApi = "https://thumbnails.roblox.com/v1/places/gameicons?placeIds=" ..
    game.PlaceId .. "&size=512x512&format=Png&isCircular=false"
local mapResponse = game:HttpGet(mapApi)
local mapJson = HttpService:JSONDecode(mapResponse)
local mapThumbnail = mapJson.data[1].imageUrl or ""

local placeId = game.PlaceId
local placeName = Marketplace:GetProductInfo(placeId).Name

local placeLink = "https://www.roblox.com/games/"..placeId

local function GetThaiTimestamp()
    local time = os.date("!*t")
    time.hour = (time.hour + 7) % 24
    return string.format("%02d-%02d-%02d %02d:%02d:%02d", time.day, time.month, time.year, time.hour, time.min, time.sec)
end
local timestamp = GetThaiTimestamp()

local color = 0
if OS == "Windows üíª" then
    color = 3447003
elseif OS == "Android ü§ñ" then
    color = 3066993
elseif OS == "iOS üçé" then
    color = 15158332
else
    color = 0
end

local data = {
    username = "ERROR HUB",
    embeds = {{
        title = "üååERRORHUB Block spin",
        color = color,
        thumbnail = { url = avatarUrl },
        image = { url = mapThumbnail },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
        fields = {
            { name = "üå† ‡∏Ñ‡∏ô‡πÉ‡∏ä‡πâ", value = plr.Name, inline = true },
            { name = "üì± ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ", value = OS, inline = true },
            { name = "üß∞ Executor", value = ExecutorText, inline = false },
            { name = "üåç ‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏°‡∏û", value = "["..placeName.."]("..placeLink..")", inline = false },
            { name = "üÜî JobId", value = tostring(game.JobId), inline = false },
            { name = "üïí ‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ô", value = timestamp, inline = false }
        }
    }}
}

local body = HttpService:JSONEncode(data)

request({
    Url = WEBHOOK_URL,
    Method = "POST",
    Headers = { ["Content-Type"] = "application/json" },
    Body = body
})

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, Mouse, UIS =
    game:GetService("Players"), game:GetService("RunService"),
    workspace.CurrentCamera, game.Players.LocalPlayer, game.Players.LocalPlayer:GetMouse(),
    game:GetService("UserInputService")

local Window = WindUI:CreateWindow({
    Title = "ERROR HUB",
    Icon = "rbxassetid://87372447687978",
    Author = "Block spin",
    Folder = "ERROR_HUB",
    Size = UDim2.fromOffset(400, 200),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

local Tab = Window:Tab({Title = "MANU", Icon = "crosshair"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Silent Aim Settings
local SilentAimEnabled = false
local FOV = 350
local PREDICTION_FACTOR = 0.165

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.new(1,1,1)
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FOV
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Color = Color3.new(1,0,0)
tracerLine.Thickness = 2
tracerLine.Visible = false

-- Find Closest Target
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOV and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- Prediction
local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end
    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end
    return prediction
end

-- Check Gun
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then
        return true
    end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- Hook FireServer
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabled and IsHoldingAllowedGun(args) then
        local target = GetClosestTarget()
        if target and target.Character and target.Character:FindFirstChild("Head") then
            local head = target.Character.Head
            local aimPos = PredictPosition(head)
            args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
        end
    end
    return oldFire(self, unpack(args))
end)

-- Update FOV & Tracer
RunService.RenderStepped:Connect(function()
    if not fovCircle then return end
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = math.clamp(FOV, 50, 1000)

    if not SilentAimEnabled then
        fovCircle.Visible = false
        tracerLine.Visible = false
        return
    end

    fovCircle.Visible = true
    local target = GetClosestTarget()
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local predictedPos = PredictPosition(target.Character.Head)
        local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
        if onScreen then
            local ourHeadPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
            if ourHeadPos then
                local screenStart, startOnScreen = Camera:WorldToViewportPoint(ourHeadPos)
                if startOnScreen then
                    tracerLine.From = Vector2.new(screenStart.X, screenStart.Y)
                    tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                    tracerLine.Visible = true
                else
                    tracerLine.Visible = false
                end
            end
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

Tab:Toggle({
    Title = "Silent Aim",
    Desc = "‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏ï‡∏≤‡∏°‡∏´‡∏±‡∏ß",
    Value = false,
    Callback = function(v)
        SilentAimEnabled = v
        fovCircle.Visible = v
        tracerLine.Visible = v
        print("[SilentAim]:", v and "Enabled" or "Disabled")
    end
})

-- FOV Slider
Tab:Slider({
    Title = "‡∏õ‡∏£‡∏±‡∏ö‡∏ß‡∏á",
    Desc = "",
    Step = 1,
    Value = {
        Min = 50,
        Max = 1000,
        Default = FOV,
    },
    Callback = function(value)
        FOV = math.clamp(value, 50, 1000)
        if fovCircle then
            fovCircle.Radius = FOV
        end
        print("[SilentAim] FOV set to:", FOV)
    end
})

  local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local DanceAndSpinEnabled = false
local danceTrack = nil

local function startDanceAndSpin()
    local char = player.Character
    if not char then return end
    local humanoid = char:WaitForChild("Humanoid")

    if not danceTrack or danceTrack.Parent ~= humanoid then
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://104767795538635"
        danceTrack = humanoid:LoadAnimation(anim)
        danceTrack.Looped = true
    end

    danceTrack:Play()
    danceTrack:AdjustSpeed(2.5)
end

local function stopDanceAndSpin()
    if danceTrack then
        danceTrack:Stop()
    end
end

-- ‡∏´‡∏°‡∏∏‡∏ô‡∏ó‡∏∏‡∏Å Frame
RunService.RenderStepped:Connect(function()
    if DanceAndSpinEnabled then
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(10), 0)
        end
    end
end)

-- ‡∏ü‡∏±‡∏á event respawn
player.CharacterAdded:Connect(function(char)
    danceTrack = nil -- ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï animation ‡πÉ‡∏´‡∏°‡πà
    local humanoid = char:WaitForChild("Humanoid")

    -- ‡∏ñ‡πâ‡∏≤‡∏ï‡∏≤‡∏¢ ‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î DanceAndSpin
    humanoid.Died:Connect(function()
        DanceAndSpinEnabled = false
        stopDanceAndSpin()
    end)

    -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏∏‡∏ô‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ß‡πâ
    if DanceAndSpinEnabled then
        startDanceAndSpin()
    end
end)

-- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
if player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            DanceAndSpinEnabled = false
            stopDanceAndSpin()
        end)
    end
end

Tab:Toggle({
    Title = "Anti Silent aim",
    Desc = "‡∏Å‡∏±‡∏ô‡∏•‡πá‡∏≠‡∏Ñ",
    Value = false,
    Callback = function(v)
        DanceAndSpinEnabled = v
        if v then
            startDanceAndSpin()
        else
            stopDanceAndSpin()
        end
    end
})
   

local ESPTab = Window:Tab({Title = "ESP", Icon = "crosshair"})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local LocalPlayer = Players.LocalPlayer

local ItemESP_Enabled = false
local BillboardCache = {}
local ItemESP_UpdateConnections = {}
local WeaponDB = {}
local PreloadedImages = {}

local RARITY_COLORS = {
    ["Common"] = Color3.fromRGB(255, 255, 255),
    ["Uncommon"] = Color3.fromRGB(99, 255, 52),
    ["Rare"] = Color3.fromRGB(51, 170, 255),
    ["Epic"] = Color3.fromRGB(237, 44, 255),
    ["Legendary"] = Color3.fromRGB(255, 150, 0),
    ["Omega"] = Color3.fromRGB(255, 20, 51),
}

local function generateUniqueKey(tool)
    if not tool or not tool:IsA("Tool") then return "TOOL_"..tool.Name end
    local itemId = tool:GetAttribute("ItemId") or tool:GetAttribute("Id")
    if itemId then return "ITEMID_" .. tostring(itemId) end
    local partsData = {}
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("SpecialMesh") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_" .. part.MeshId .. "|TEX_" .. (part.TextureId or "NONE"))
        elseif part:IsA("MeshPart") and part.MeshId ~= "" then
            table.insert(partsData, "MESH_" .. part.MeshId .. "|TEX_" .. (part.TextureID or "NONE"))
        elseif part:IsA("Decal") and part.Texture ~= "" then
            table.insert(partsData, "DECAL_" .. part.Texture)
        elseif part:IsA("Part") then
            table.insert(partsData, "PART_" .. part.Name)
        end
    end
    if #partsData > 0 then
        table.sort(partsData)
        return "MESHKEY_" .. table.concat(partsData, ";")
    end
    return "NAME_" .. tool.Name
end

local function registerItems(folder)
    for _, tool in ipairs(folder:GetDescendants()) do
        if not tool:IsA("Tool") then continue end
        local key = generateUniqueKey(tool)
        if not key then continue end
        local displayName = tool:GetAttribute("DisplayName") or tool.Name
        local imageId = tool:GetAttribute("ImageId") or "rbxassetid://7072725737"
        local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"

        WeaponDB[key] = {
            Name = displayName,
            Rarity = rarity,
            ImageId = imageId,
            ToolName = tool.Name,
            Key = key
        }

        if imageId and not PreloadedImages[imageId] then
            PreloadedImages[imageId] = true
            task.spawn(function()
                local img = Instance.new("ImageLabel")
                img.Image = imageId
                img.Size = UDim2.new(0,0,0,0)
                img.Parent = workspace
                pcall(function()
                    ContentProvider:PreloadAsync({img})
                end)
                img:Destroy()
            end)
        end
    end
end

pcall(function()
    local itemsFolder = ReplicatedStorage:WaitForChild("Items", 5)
    if itemsFolder then registerItems(itemsFolder) end
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        if obj:IsA("Folder") and (obj.Name:find("Weapon") or obj.Name:find("Item") or obj.Name:find("Tool")) then
            registerItems(obj)
        end
    end
    registerItems(game:GetService("StarterPack"))
end)

local function getWeaponInfo(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    return WeaponDB[ generateUniqueKey(tool) ]
end

local function createBillboardForPlayer(player)
    if player == LocalPlayer or BillboardCache[player] then return end
    local billboard, container
    local connections = {}

    local function updateESP()
        if not ItemESP_Enabled or not billboard or not billboard.Parent then return end
        local tools = {}
        local function scan(folder)
            if not folder then return end
            for _, tool in ipairs(folder:GetChildren()) do
                if tool:IsA("Tool") then
                    local info = getWeaponInfo(tool)
                    if info then table.insert(tools, info) end
                end
            end
        end
        local char = player.Character
        if char then scan(char) end
        if player.Backpack then scan(player.Backpack) end

        for _, child in ipairs(container:GetChildren()) do
            if child:IsA("ImageLabel") then child:Destroy() end
        end

        local layout = container:FindFirstChildOfClass("UIGridLayout")
        if not layout then
            layout = Instance.new("UIGridLayout")
            layout.CellSize = UDim2.new(0, 35, 0, 35)
            layout.CellPadding = UDim2.new(0, 6, 0, 0)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.Parent = container
        end

        for i, info in ipairs(tools) do
            local img = Instance.new("ImageLabel")
            img.Parent = container
            img.Size = UDim2.new(0, 35, 0, 35)
            img.BackgroundTransparency = 1
            img.Image = info.ImageId
            img.ScaleType = Enum.ScaleType.Fit
            img.LayoutOrder = i
            local color = RARITY_COLORS[info.Rarity] or Color3.new(1,1,1)
            img.ImageColor3 = color:Lerp(Color3.new(1,1,1), 0.35)
        end
    end

    local function setupBillboard()
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        if BillboardCache[player] then BillboardCache[player]:Destroy() end

        billboard = Instance.new("BillboardGui")
        billboard.Name = "ItemESP"
        billboard.Adornee = hrp
        billboard.Size = UDim2.new(0, 280, 0, 40)
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = hrp

        container = Instance.new("Frame", billboard)
        container.BackgroundTransparency = 1
        container.Size = UDim2.new(1, 0, 1, 0)

        BillboardCache[player] = billboard
        updateESP()

        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            table.insert(connections, backpack.ChildAdded:Connect(updateESP))
            table.insert(connections, backpack.ChildRemoved:Connect(updateESP))
        end

        table.insert(connections, char.ChildAdded:Connect(function(c)
            if c:IsA("Tool") then updateESP() end
        end))
        table.insert(connections, char.ChildRemoved:Connect(function(c)
            if c:IsA("Tool") then updateESP() end
        end))
    end

    if player.Character then
        task.spawn(setupBillboard)
    end

    table.insert(connections, player.CharacterAdded:Connect(function()
        task.wait(0.5)
        setupBillboard()
    end))

    ItemESP_UpdateConnections[player] = connections
end

for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then createBillboardForPlayer(p) end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then createBillboardForPlayer(p) end
end)

Players.PlayerRemoving:Connect(function(p)
    if BillboardCache[p] then BillboardCache[p]:Destroy() end
    if ItemESP_UpdateConnections[p] then
        for _, c in ipairs(ItemESP_UpdateConnections[p]) do
            if c.Connected then c:Disconnect() end
        end
    end
    BillboardCache[p] = nil
    ItemESP_UpdateConnections[p] = nil
end)

ESPTab:Toggle({
    Title = "Item ESP",
    Desc = "‡∏î‡∏π‡∏Ç‡∏≠‡∏á",
    Value = ItemESP_Enabled,
    Callback = function(v)
        ItemESP_Enabled = v
        for _, billboard in pairs(BillboardCache) do
            if billboard and billboard.Parent then
                billboard.Enabled = v
            end
        end
    end
})
 local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ ESP
local ESPSettings = {
    Enabled = true,
    Box = true,
    HP = true,
    Name = true,
    Skeleton = true,
}

local ESPCache = {}

local function createESP(player)
    if player == LocalPlayer then return end
    if ESPCache[player] then return end

    local box = Drawing.new("Square")
    box.Thickness = 1.5
    box.Filled = false
    box.Color = Color3.fromRGB(255,255,255)

    local hpBar = Drawing.new("Square")
    hpBar.Filled = true
    hpBar.Color = Color3.fromRGB(0,255,0)

    local name = Drawing.new("Text")
    name.Size = 14
    name.Center = true
    name.Outline = true
    name.Color = Color3.fromRGB(255,255,255)
    name.Text = player.Name

    local skeleton = {}
    local function makeLine()
        local l = Drawing.new("Line")
        l.Color = Color3.fromRGB(0,255,0)
        l.Thickness = 2
        return l
    end
    for i = 1, 6 do
        table.insert(skeleton, makeLine())
    end

    ESPCache[player] = {
        box = box,
        hpBar = hpBar,
        name = name,
        skeleton = skeleton
    }
end

Players.PlayerRemoving:Connect(function(player)
    if not ESPCache[player] then return end
    for _, obj in pairs(ESPCache[player]) do
        if type(obj) == "table" then
            for _, l in ipairs(obj) do if l.Remove then l:Remove() end end
        elseif obj.Remove then
            obj:Remove()
        end
    end
    ESPCache[player] = nil
end)

for _, plr in ipairs(Players:GetPlayers()) do
    createESP(plr)
end
Players.PlayerAdded:Connect(createESP)

RunService.RenderStepped:Connect(function()
    if not ESPSettings.Enabled then
        for _, v in pairs(ESPCache) do
            for _, d in pairs(v) do
                if type(d) == "table" then
                    for _, l in pairs(d) do l.Visible = false end
                else
                    d.Visible = false
                end
            end
        end
        return
    end

    for player, item in pairs(ESPCache) do
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local head = char and char:FindFirstChild("Head")
        local torso = char and (char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso"))

        if not (char and hrp and hum and head and torso) then
            for _, d in pairs(item) do
                if type(d) == "table" then
                    for _, l in pairs(d) do l.Visible = false end
                else
                    d.Visible = false
                end
            end
            continue
        end

        local size = char:GetExtentsSize()
        local top = hrp.Position + Vector3.new(0, size.Y/2, 0)
        local bottom = hrp.Position - Vector3.new(0, size.Y/2, 0)

        local top2d, topVisible = Camera:WorldToViewportPoint(top)
        local bot2d, botVisible = Camera:WorldToViewportPoint(bottom)

        if not topVisible and not botVisible then
            item.box.Visible = false
            item.hpBar.Visible = false
            item.name.Visible = false
            for _, l in pairs(item.skeleton) do l.Visible = false end
            continue
        end

        local height2d = math.abs(top2d.Y - bot2d.Y)
        local width2d = height2d / 2

        item.box.Size = Vector2.new(width2d, height2d)
        item.box.Position = Vector2.new(top2d.X - width2d/2, top2d.Y)
        item.box.Visible = ESPSettings.Box

        item.hpBar.Size = Vector2.new(5, height2d * (hum.Health / hum.MaxHealth))
        item.hpBar.Position = Vector2.new(item.box.Position.X - 6, item.box.Position.Y + (height2d - item.hpBar.Size.Y))
        item.hpBar.Visible = ESPSettings.HP

        item.name.Position = Vector2.new(top2d.X, top2d.Y - 15)
        item.name.Visible = ESPSettings.Name

        if ESPSettings.Skeleton then
            local larm = char:FindFirstChild("LeftUpperArm") or char:FindFirstChild("Left Arm")
            local rarm = char:FindFirstChild("RightUpperArm") or char:FindFirstChild("Right Arm")
            local lleg = char:FindFirstChild("LeftUpperLeg") or char:FindFirstChild("Left Leg")
            local rleg = char:FindFirstChild("RightUpperLeg") or char:FindFirstChild("Right Leg")

            local bones = {
                {head, torso},
                {torso, larm},
                {torso, rarm},
                {torso, lleg},
                {torso, rleg},
                {larm, rarm}
            }

            for i, pair in ipairs(bones) do
                local a, b = pair[1], pair[2]
                local line = item.skeleton[i]
                if a and b then
                    local a2d, aVis = Camera:WorldToViewportPoint(a.Position)
                    local b2d, bVis = Camera:WorldToViewportPoint(b.Position)
                    if aVis and bVis then
                        line.From = Vector2.new(a2d.X, a2d.Y)
                        line.To = Vector2.new(b2d.X, b2d.Y)
                        line.Visible = true
                    else
                        line.Visible = false
                    end
                else
                    line.Visible = false
                end
            end
        end
    end
end)

ESPTab:Toggle({
    Title = "ESP",
    Desc = "‡∏°‡∏≠‡∏á‡∏Ñ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏ü",
    Default = false,
    Callback = function(state)
        ESPSettings.Enabled = state
    end
})

-- == Global Variables ==
-- Silent Aim
local SilentAimEnabled = false
local SilentAimAttachEnabled = false
local GoodGunEnabled = false
local FOVRadius = 120
local CurrentTarget = nil
local SilentFOVCircle = nil
local Tracer = Drawing.new("Line")
Tracer.Thickness = 1
Tracer.Color = Color3.fromRGB(255, 50, 50)
Tracer.Transparency = 1
Tracer.Visible = false

-- == Utility Functions ==
local function getPing()
    local stats = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("NetworkStats")
    if stats then
        local pingText = stats:FindFirstChild("PingLabel")
        if pingText and typeof(pingText.Text) == "string" then
            local ping = tonumber(pingText.Text:match("%d+"))
            return ping and ping / 1000 or 0.2
        end
    end
    return 0.2
end

local function isPlayerExcluded(playerName)
    for _, excludedName in ipairs(excludedPlayerNames) do
        if excludedName ~= "" and string.find(string.lower(playerName), string.lower(excludedName)) then
            return true
        end
    end
    return false
end

local function getClosestTarget()
    local closest = nil
    local shortestDistance = FOVRadius -- ‡πÉ‡∏ä‡πâ FOV ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if head and humanoid and humanoid.Health > 0 and hrp then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local screenVector = Vector2.new(screenPos.X, screenPos.Y)
                    local distanceFromCenter = (screenVector - center).Magnitude
                    -- ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô FOV ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô
                    if distanceFromCenter <= FOVRadius and not isPlayerExcluded(player.Name) then
                        if distanceFromCenter < shortestDistance then
                            shortestDistance = distanceFromCenter
                            closest = player
                        end
                    end
                end
            end
        end
    end
    return closest
end

local function predictPosition(head, hrp)
    local ping = getPing()
    local velocity = hrp and hrp.Velocity or Vector3.zero
    return head.Position + (velocity * ping * 1.15)
end

local function isBehindWall(startPos, endPos)
    if not startPos or not endPos then
        return false
    end
    local ray = Ray.new(startPos, endPos - startPos)
    local ignoreList = {}
    if LocalPlayer.Character then
        table.insert(ignoreList, LocalPlayer.Character)
    end
    if CurrentTarget and CurrentTarget.Character then
        table.insert(ignoreList, CurrentTarget.Character)
    end
    local hit = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    return hit ~= nil
end

-- == Silent FOV Circle Setup ==
if not isMobile then
    SilentFOVCircle = Drawing.new("Circle")
    SilentFOVCircle.Color = Color3.fromRGB(255, 255, 255)
    SilentFOVCircle.Thickness = 2 -- Increased thickness for better visibility
    SilentFOVCircle.NumSides = 64
    SilentFOVCircle.Filled = false
    SilentFOVCircle.Transparency = 0.8 -- Slightly less transparent for better visibility
    SilentFOVCircle.Radius = FOVRadius
    SilentFOVCircle.Visible = false
else
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "MobileFOV"
    ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    SilentFOVCircle = Instance.new("Frame")
    SilentFOVCircle.Size = UDim2.fromOffset(FOVRadius * 2, FOVRadius * 2)
    SilentFOVCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    SilentFOVCircle.Position = UDim2.fromScale(0.5, 0.5)
    SilentFOVCircle.BackgroundTransparency = 1
    local circleUI = Instance.new("UICorner")
    circleUI.CornerRadius = UDim.new(1, 0)
    circleUI.Parent = SilentFOVCircle
    local border = Instance.new("UIStroke")
    border.Color = Color3.fromRGB(255, 255, 255)
    border.Thickness = 2 -- Increased thickness for better visibility
    border.Transparency = 0.2 -- Slightly less transparent for better visibility
    border.Parent = SilentFOVCircle
    SilentFOVCircle.Parent = ScreenGui
end

-- == ENHANCED SMART SILENT AIM SYSTEM ==
local oldFire
if Remote and Remote.FireServer then
    local ok, res = pcall(function()
        oldFire = hookfunction(Remote.FireServer, function(self, ...)
            if self ~= Remote then return oldFire(self, ...) end
            local args = {...}
            
            if (SilentAimEnabled or GoodGunEnabled) and args[2] == "shoot_gun" and CurrentTarget then
                local head = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head")
                local hrp = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = CurrentTarget.Character:FindFirstChild("Humanoid")
                
                if head and humanoid and hrp and humanoid.Health > 0 then
                    local aimPos = predictPosition(head, hrp)
                    local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
                    
                    if myHead then
                        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≥‡πÅ‡∏û‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                        local isTargetBehindWall = isBehindWall(myHead.Position, aimPos)
                        
                        -- ‡∏£‡∏∞‡∏ö‡∏ö‡∏â‡∏•‡∏≤‡∏î: ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≥‡πÅ‡∏û‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏¥‡∏î GoodGun ‡πÉ‡∏´‡πâ‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏, ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡πá‡∏¢‡∏¥‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
                        if GoodGunEnabled and isTargetBehindWall then
                            -- ‡πÇ‡∏´‡∏°‡∏î‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏‡∏Å‡∏≥‡πÅ‡∏û‡∏á
                            args[4] = CFrame.new(math.huge, math.huge, math.huge)
                            args[5] = {
                                [1] = {
                                    [1] = {
                                        ["Instance"] = head,
                                        ["Normal"] = Vector3.new(0, 1, 0),
                                        ["Position"] = aimPos
                                    }
                                }
                            }
                        else
                            -- ‡πÇ‡∏´‡∏°‡∏î‡∏¢‡∏¥‡∏á‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÑ‡∏°‡πà‡∏ó‡∏∞‡∏•‡∏∏‡∏Å‡∏≥‡πÅ‡∏û‡∏á)
                            args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
                            args[5] = {
                                [1] = {
                                    [1] = {
                                        ["Instance"] = head,
                                        ["Normal"] = Vector3.new(0, 1, 0),
                                        ["Position"] = aimPos
                                    }
                                }
                            }
                        end

                        -- ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô
                        local myPos = LocalPlayer.Character.Head.Position
                        local success, beam = pcall(function()
                            local part = Instance.new("Part")
                            part.Anchored = true
                            part.CanCollide = false
                            part.Size = Vector3.new(0.15, 0.15, (aimPos - myPos).Magnitude)
                            part.CFrame = CFrame.new(myPos, aimPos) * CFrame.new(0, 0, -part.Size.Z / 2)
                            part.Material = Enum.Material.Neon
                            part.Transparency = 0.25
                            part.Color = (GoodGunEnabled and isTargetBehindWall) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 50, 50)
                            part.Parent = Workspace
                            Debris:AddItem(part, 4)
                            return part
                        end)

                        -- ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡∏¥‡∏á‡πÇ‡∏î‡∏ô
                        spawn(function()
                            wait(0.1)
                            if humanoid and humanoid.Health < humanoid.MaxHealth then
                                -- ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏¢‡∏¥‡∏á‡πÇ‡∏î‡∏ô
                                for _, part in ipairs(CurrentTarget.Character:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        local box = Instance.new("Part")
                                        box.Size = part.Size + Vector3.new(0.05, 0.05, 0.05)
                                        box.CFrame = part.CFrame
                                        box.Anchored = true
                                        box.CanCollide = false
                                        box.Material = Enum.Material.Neon
                                        box.Color = (GoodGunEnabled and isTargetBehindWall) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(128, 0, 128)
                                        box.Transparency = 0.5
                                        box.Parent = Workspace
                                        local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Linear)
                                        TweenService:Create(box, tweenInfo, {Transparency = 1}):Play()
                                        Debris:AddItem(box, 2)
                                    end
                                end
                            end
                        end)
                    end
                end
            end

            return oldFire(self, unpack(args))
        end)
    end)

    if not ok then
        warn("Warning: failed to hook Remote.FireServer")
    end
end

-- Main Render Loop
RunService.RenderStepped:Connect(
    function()
        pcall(
            function()
                if SilentAimAttachEnabled then
                    CurrentTarget = getClosestTarget()
                end
                if SilentFOVCircle then
                    SilentFOVCircle.Visible = SilentAimEnabled or SilentAimAttachEnabled or GoodGunEnabled
                    if isMobile then
                        SilentFOVCircle.Position = UDim2.fromScale(0.5, 0.5)
                        SilentFOVCircle.Size = UDim2.fromOffset(FOVRadius * 2, FOVRadius * 2)
                    else
                        SilentFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        SilentFOVCircle.Radius = FOVRadius
                    end
                end
                CurrentTarget = (SilentAimEnabled or SilentAimAttachEnabled or GoodGunEnabled) and getClosestTarget() or nil
                if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
                    local targetHead = CurrentTarget.Character.Head
                    local humanoid = CurrentTarget.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local centerScreenPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- Center of FOV circle
                        local targetScreenPos, targetOnScreen = Camera:WorldToViewportPoint(targetHead.Position)
                        if targetOnScreen then
                            Tracer.Visible = true
                            Tracer.From = centerScreenPos -- Start from center of FOV circle
                            Tracer.To = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                            Tracer.Color = GoodGunEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 50, 50)
                        else
                            Tracer.Visible = false
                        end
                    else
                        Tracer.Visible = false
                    end
                else
                    Tracer.Visible = false
                end
            end
        )
    end
)

-- == UI Tabs ==
local Tab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})

-- Silent Aim Toggle
local SilentToggle = Tab:Toggle(
    {
        Title = "Silent Aim",
        Default = false,
        Callback = function(state)
            SilentAimEnabled = state
            CurrentTarget = nil
            if state then
                GoodGunEnabled = false
                SilentAimAttachEnabled = false
                if GoodGunToggle then
                    GoodGunToggle:Set(false)
                end
                if AttachToggle then
                    AttachToggle:Set(false)
                end
            end
        end
    }
)
myConfig:Register("SilentAim", SilentToggle)

-- Good Gun Toggle (Silent Aim ‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏)
local GoodGunToggle =
    Tab:Toggle(
    {
        Title = "‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏",
        Default = false,
        Callback = function(state)
            GoodGunEnabled = state
            CurrentTarget = nil
            if state then
                SilentAimEnabled = false
                SilentAimAttachEnabled = false
                if SilentToggle then
                    SilentToggle:Set(false)
                end
                if AttachToggle then
                    AttachToggle:Set(false)
                end
            end
        end
    }
)
myConfig:Register("GoodGun", GoodGunToggle)

-- Silent Aim Attach Toggle
local AttachToggle = Tab:Toggle(
    {
        Title = "Silent Aim Attach",
        Default = false,
        Callback = function(state)
            SilentAimAttachEnabled = state
            CurrentTarget = nil
            if state then
                SilentAimEnabled = false
                GoodGunEnabled = false
                if SilentToggle then
                    SilentToggle:Set(false)
                end
                if GoodGunToggle then
                    GoodGunToggle:Set(false)
                end
            end
        end
    }
)
myConfig:Register("SilentAimAttach", AttachToggle)

-- FOV Slider
local FOVSlider =
    Tab:Slider(
    {
        Title = "FOV: ",
        Step = 1,
        Value = {
            Min = 20,
            Max = 750,
            Default = FOVRadius
        },
        Callback = function(value)
            FOVRadius = tonumber(value) or 120
            if SilentFOVCircle then
                if isMobile then
                    SilentFOVCircle.Size = UDim2.fromOffset(FOVRadius * 2, FOVRadius * 2)
                else
                    SilentFOVCircle.Radius = FOVRadius
                end
            end
        end
    }
)
myConfig:Register("FOVRadius", FOVSlider)

-- Friends List Input
local FriendsInput =
    Tab:Input(
    {
        Title = "Safe Friend List",
        Desc = "Enter Player Name",
        Value = "",
        InputIcon = "shield-check",
        Type = "Input",
        Placeholder = "",
        Callback = function(input)
            excludedPlayerNames = {}
            for name in string.gmatch(input, "%S+") do
                table.insert(excludedPlayerNames, name)
            end
            for _, player in pairs(Players:GetPlayers()) do
                if espPlayers[player] and espPlayers[player].drawings then
                    local nameText = espPlayers[player].drawings[1]
                    nameText.Color = 
                        isPlayerExcluded(player.Name) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)
                end
            end
        end
    }
)
myConfig:Register("FriendsList", FriendsInput)

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer
local placeId = game.PlaceId

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Tab ‡∏ä‡∏∑‡πà‡∏≠ "Server"
local ServerTab = Window:Tab({Title = "Server", Icon = "globe"})

-- 1Ô∏è‚É£ Join Job (‡∏Å‡∏£‡∏≠‡∏Å JobId ‡πÄ‡∏≠‡∏á)
local jobInput = ""
ServerTab:Input({
    Title = "JobId",
    Desc = "‡πÉ‡∏™‡πà JobId ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ",
    Placeholder = "",
    Callback = function(text)
        jobInput = text
    end
})

ServerTab:Button({
    Title = "Join Job",
    Callback = function()
        if jobInput ~= "" then
            TeleportService:TeleportToPlaceInstance(placeId, jobInput, player)
        else
            warn("‡πÉ‡∏™‡πà JobId ‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å")
        end
    end
})

-- 2Ô∏è‚É£ Copy JobId
ServerTab:Button({
    Title = "Copy JobId",
    Desc = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏à‡πá‡∏≠‡∏õ‡πÑ‡∏≠‡∏î‡∏µ",
    Callback = function()
        setclipboard(game.JobId)
        print("Copied JobId:", game.JobId)
    end
})

-- 3Ô∏è‚É£ Rejoin
ServerTab:Button({
    Title = "Rejoin",
    Desc = "‡∏≠‡∏≠‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà",
    Callback = function()
        TeleportService:TeleportToPlaceInstance(placeId, game.JobId, player)
    end
})

-- 4Ô∏è‚É£ Server Hop (‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü)
ServerTab:Button({
    Title = "Server Hop",
    Desc = "‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÉ‡∏´‡∏°‡πà",
    Callback = function()
        local success, servers = pcall(function()
            local url = "https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"
            return HttpService:JSONDecode(game:HttpGet(url))
        end)

        if success and servers and servers.data then
            for _, server in pairs(servers.data) do
                if server.id ~= game.JobId and server.playing < server.maxPlayers then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id, player)
                    return
                end
            end
            warn("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏ß‡πà‡∏≤‡∏á")
        else
            warn("‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        end
    end
})

-- 5Ô∏è‚É£ Small Server (‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏™‡∏∏‡∏î)
ServerTab:Button({
    Title = "Small Server",
    Desc = "‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏Ñ‡∏ô‡∏ô‡πâ‡∏≠‡∏¢",
    Callback = function()
        local success, servers = pcall(function()
            local url = "https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100"
            return HttpService:JSONDecode(game:HttpGet(url))
        end)

        if success and servers and servers.data then
            table.sort(servers.data, function(a,b)
                return a.playing < b.playing
            end)

            for _, server in pairs(servers.data) do
                if server.id ~= game.JobId and server.playing < server.maxPlayers then
                    TeleportService:TeleportToPlaceInstance(placeId, server.id, player)
                    return
                end
            end
            warn("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏ß‡πà‡∏≤‡∏á")
        else
            warn("‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        end
    end
})
