--// ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÇ‡∏´‡∏•‡∏î
local SoundService = game:GetService("SoundService")
local loadSound = Instance.new("Sound")
loadSound.SoundId = "rbxassetid://98797174600699"
loadSound.Volume = 1
loadSound.Parent = SoundService
loadSound:Play()
game.Debris:AddItem(loadSound, 3)

--// UI Framework
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()

--// Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

--// ‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å
local Window = Library:Window({
    Title = "ERROR HUB",
    Desc = "Beta!!!!",
    Icon = 87372447687978,
    Theme = "Dark",
    Config = { Keybind = Enum.KeyCode.LeftControl, Size = UDim2.new(0, 450, 0, 350) },
    CloseUIButton = { Enabled = true, Text = "ERROR" }
})

----------------------------------------------------
--== ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏•‡∏±‡∏Å ==--
----------------------------------------------------

local humanoid
local jumpEnabled, jumpValue = false, 100
local tpWalkEnabled, tpWalkLevel, tpWalkSpeed, tpWalkThread = false, 1, 50, nil
local noclipEnabled = false
local followEnabled, followTarget, followLoop, followMode, followDistance = false, nil, nil, "Tween", 16

local function updateHumanoid()
    local char = player.Character
    if char then humanoid = char:FindFirstChildOfClass("Humanoid") end
end
updateHumanoid()

local function updateTpWalkSpeed()
    tpWalkSpeed = tpWalkLevel * 50
end

local function toggleTpWalk(on)
    tpWalkEnabled = on
    if tpWalkThread then
        tpWalkThread:Disconnect()
        tpWalkThread = nil
    end
    if on then
        tpWalkThread = RunService.Heartbeat:Connect(function(dt)
            local char = player.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if not (char and root and hum) then return end
            local moveDir = hum.MoveDirection
            if moveDir.Magnitude > 0 then
                root.CFrame = root.CFrame + moveDir * (tpWalkSpeed * dt)
            end
        end)
    end
end

local function reapplySettings()
    task.wait(1.5)
    updateHumanoid()

    if jumpEnabled and humanoid then
        humanoid.UseJumpPower = true
        humanoid.JumpPower = jumpValue
    end

    if tpWalkEnabled then toggleTpWalk(true) end

    if noclipEnabled then
        task.spawn(function()
            while noclipEnabled and task.wait(0.05) do
                if not player.Character then break end
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end

    if followEnabled and followTarget then
        task.spawn(function()
            while followEnabled and task.wait(0.01) do
                if not (player.Character and followTarget.Character) then break end
                local myRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local targetRoot = followTarget.Character:FindFirstChild("HumanoidRootPart")
                if not (myRoot and targetRoot) then break end
                local targetY = targetRoot.Position.Y
                local behindVector = -targetRoot.CFrame.LookVector * followDistance
                local targetPos = targetRoot.Position + behindVector
                local newPos = Vector3.new(targetPos.X, targetY, targetPos.Z)
                local lookAt = Vector3.new(targetRoot.Position.X, targetY, targetRoot.Position.Z)
                local newCFrame = CFrame.new(newPos, lookAt)
                if followMode == "Teleport" then
                    myRoot.CFrame = newCFrame
                elseif followMode == "Tween" then
                    local tweenInfo = TweenInfo.new(0.02, Enum.EasingStyle.Linear)
                    local tween = TweenService:Create(myRoot, tweenInfo, {CFrame = newCFrame})
                    tween:Play()
                end
            end
        end)
    end
end

player.CharacterAdded:Connect(function(char)
    humanoid = char:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        Window:Notify({Title = "üíÄ", Desc = "‡∏Ñ‡∏∏‡∏ì‡∏ï‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß!", Time = 3})
    end)
    reapplySettings()
end)

----------------------------------------------------
--== TAB: Main ==--
----------------------------------------------------
local MainTab = Window:Tab({Title = "Main", Icon = "zap"}) do
    MainTab:Toggle({
        Title = "üèÉ ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß",
        Value = false,
        Callback = function(v) toggleTpWalk(v) end
    })
    MainTab:Slider({
        Title = "‚ö° ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß",
        Min = 1, Max = 5, Value = tpWalkLevel,
        Callback = function(val) tpWalkLevel = val updateTpWalkSpeed() end
    })
    MainTab:Toggle({
        Title = "ü¶ò ‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î‡∏™‡∏π‡∏á",
        Value = false,
        Callback = function(v)
            jumpEnabled = v
            if humanoid then
                humanoid.UseJumpPower = true
                humanoid.JumpPower = v and jumpValue or 50
            end
        end
    })
    MainTab:Slider({
        Title = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á",
        Min = 50, Max = 300, Value = jumpValue,
        Callback = function(val)
            jumpValue = val
            if jumpEnabled and humanoid then
                humanoid.JumpPower = val
            end
        end
    })
    MainTab:Toggle({
        Title = "‡∏ó‡∏∞‡∏•‡∏∏‡∏™‡∏¥‡πà‡∏á‡∏Ç‡∏≠‡∏á",
        Value = false,
        Callback = function(v) noclipEnabled = v end
    })
    RunService.Stepped:Connect(function()
        if not noclipEnabled then return end
        local char = player.Character
        if not char then return end
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

----------------------------------------------------
--== TAB: TP ==--
----------------------------------------------------
local TPTab = Window:Tab({Title = "TP", Icon = "map-pin"})
local selectedPlayerName, playerNames = "", {}

local function UpdatePlayerList()
    playerNames = {}
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player then table.insert(playerNames, p.DisplayName .. " (" .. p.Name .. ")") end
    end
end
UpdatePlayerList()
Players.PlayerAdded:Connect(UpdatePlayerList)
Players.PlayerRemoving:Connect(UpdatePlayerList)

TPTab:Textbox({
    Title = "‡∏û‡∏¥‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ó‡πÄ‡∏•‡∏û‡∏≠‡∏£‡πå‡∏ï‡∏´‡∏≤",
    Placeholder = "(‡πÅ‡∏Ñ‡πà 3 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å‡∏Å‡πá‡∏û‡∏≠)",
    Callback = function(text) selectedPlayerName = text end
})
TPTab:Dropdown({
    Title = "üéØ ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏≤‡∏°",
    List = {"Tween", "Teleport"},
    Value = "Tween",
    Callback = function(val) followMode = val end
})
TPTab:Slider({
    Title = "‡∏£‡∏∞‡∏¢‡∏∞",
    Min = 1, Max = 50, Value = followDistance,
    Callback = function(val) followDistance = val end
})
TPTab:Toggle({
    Title = "üîÅ ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å",
    Value = false,
    Callback = function(v)
        followEnabled = v
        if v then
            local input = string.lower(selectedPlayerName)
            if #input < 3 then followEnabled = false return end
            for _, p in pairs(Players:GetPlayers()) do
                if string.lower(p.Name):sub(1, #input) == input or string.lower(p.DisplayName):sub(1, #input) == input then
                    followTarget = p break
                end
            end
            reapplySettings()
        else
            followTarget = nil
        end
    end
})
TPTab:Button({
    Title = "üöÄ ‡πÄ‡∏ó‡πÄ‡∏•‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÑ‡∏õ‡∏´‡∏≤‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å",
    Desc = "‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πá‡∏Å‡∏î‡πÄ‡∏•‡∏¢",
    Callback = function()
        local input = string.lower(selectedPlayerName)
        for _, p in pairs(Players:GetPlayers()) do
            if string.lower(p.Name):sub(1, #input) == input or string.lower(p.DisplayName):sub(1, #input) == input then
                if p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = p.Character.HumanoidRootPart.CFrame + Vector3.new(0,3,0)
                end
            end
        end
    end
})
local PlayerListBox = TPTab:Code({
    Title = "‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏ü‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâüë•",
    Code = table.concat(playerNames, "\n")
})
task.spawn(function()
    while task.wait(2) do
        UpdatePlayerList()
        PlayerListBox:SetCode(table.concat(playerNames, "\n"))
    end
end)

----------------------------------------------------
--== TAB: Player (ESP 2D ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏à‡∏≠) ==--
----------------------------------------------------
local PlayerTab = Window:Tab({Title = "Player", Icon = "user"}) do
    PlayerTab:Section({Title = "ESP"})

    local Camera = workspace.CurrentCamera
    local esp, espEnabled, RunServiceConnection = {}, false, nil

    repeat task.wait() until Camera and Camera.ViewportSize.X > 0

    local function createDrawsFor(plr)
        if esp[plr] then return end
        local line = Drawing.new("Line")
        line.Color = Color3.fromRGB(170, 0, 255)
        line.Thickness = 1.6
        line.Transparency = 1
        line.Visible = false

        local boxLines = {}
        for i = 1, 4 do
            local l = Drawing.new("Line")
            l.Color = Color3.fromRGB(170, 0, 255)
            l.Thickness = 1.4
            l.Transparency = 1
            l.Visible = false
            table.insert(boxLines, l)
        end

        local txt = Drawing.new("Text")
        txt.Color = Color3.fromRGB(255, 255, 255)
        txt.Size = 14
        txt.Center = true
        txt.Outline = true
        txt.Font = 2
        txt.Visible = false

        esp[plr] = { Line = line, BoxLines = boxLines, Text = txt }
    end

    local function removeDrawsFor(plr)
        local o = esp[plr]
        if not o then return end
        if o.Line then o.Line:Remove() end
        for _, l in pairs(o.BoxLines or {}) do l:Remove() end
        if o.Text then o.Text:Remove() end
        esp[plr] = nil
    end

    local function clearAllDraws()
        for plr in pairs(esp) do removeDrawsFor(plr) end
    end

    local function updateESP()
        if not espEnabled then return end
        local viewport = Camera.ViewportSize
        local topCenter = Vector2.new(viewport.X * 0.5, 0) -- üî• ‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡∏à‡∏≠

        for plr, d in pairs(esp) do
            local char = plr.Character
            if not char then
                d.Line.Visible = false
                for _, l in pairs(d.BoxLines) do l.Visible = false end
                d.Text.Visible = false
            else
                local head = char:FindFirstChild("Head")
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if not head or not hrp then continue end

                local rootScreen, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                local headScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.4, 0))
                local footScreen = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 2.5, 0))

                if onScreen then
                    local height = math.abs(headScreen.Y - footScreen.Y)
                    local width = height / 2
                    local topLeft = Vector2.new(rootScreen.X - width / 2, rootScreen.Y - height / 2)
                    local topRight = Vector2.new(rootScreen.X + width / 2, rootScreen.Y - height / 2)
                    local bottomLeft = Vector2.new(rootScreen.X - width / 2, rootScreen.Y + height / 2)
                    local bottomRight = Vector2.new(rootScreen.X + width / 2, rootScreen.Y + height / 2)

                    d.BoxLines[1].From, d.BoxLines[1].To = topLeft, topRight
                    d.BoxLines[2].From, d.BoxLines[2].To = topRight, bottomRight
                    d.BoxLines[3].From, d.BoxLines[3].To = bottomRight, bottomLeft
                    d.BoxLines[4].From, d.BoxLines[4].To = bottomLeft, topLeft
                    for _, l in pairs(d.BoxLines) do l.Visible = true end

                    d.Line.From = topCenter -- ‚úÖ ‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡∏à‡∏≠‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
                    d.Line.To = Vector2.new(rootScreen.X, rootScreen.Y)
                    d.Line.Visible = true

                    local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                    d.Text.Position = Vector2.new(rootScreen.X, topLeft.Y - 20)
                    d.Text.Text = string.format("%s [%.1f]", plr.DisplayName, distance)
                    d.Text.Visible = true
                else
                    d.Line.Visible = false
                    for _, l in pairs(d.BoxLines) do l.Visible = false end
                    d.Text.Visible = false
                end
            end
        end
    end

    local function startESP()
        if espEnabled then return end
        espEnabled = true
        for _, p in ipairs(Players:GetPlayers()) do if p ~= player then createDrawsFor(p) end end
        RunServiceConnection = RunService.RenderStepped:Connect(updateESP)
        Players.PlayerAdded:Connect(function(p) if espEnabled and p ~= player then createDrawsFor(p) end end)
        Players.PlayerRemoving:Connect(function(p) removeDrawsFor(p) end)
    end

    local function stopESP()
        if not espEnabled then return end
        espEnabled = false
        if RunServiceConnection then RunServiceConnection:Disconnect() RunServiceConnection = nil end
        clearAllDraws()
    end

    PlayerTab:Toggle({
        Title = "‡∏°‡∏≠‡∏á‡∏Ñ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏ü",
        Value = false,
        Callback = function(v)
            if v then
                startESP()
                Window:Notify({Title = "‚úÖ ESP ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", Time = 3})
            else
                stopESP()
                Window:Notify({Title = "üõë ‡∏õ‡∏¥‡∏î ESP", Time = 3})
            end
        end
    })
end
     local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

--// UI setup
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TargetCircleUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

--// ‡∏ß‡∏á‡∏Å‡∏•‡∏° UI ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠
local circleSize = 250 -- ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏° (px)
local circle = Instance.new("Frame")
circle.Name = "CenterCircle"
circle.Size = UDim2.fromOffset(circleSize, circleSize)
circle.AnchorPoint = Vector2.new(0.5, 0.5)
circle.Position = UDim2.fromScale(0.5, 0.5)
circle.BackgroundTransparency = 1
circle.Visible = false -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡πà‡∏≠‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°
circle.Parent = screenGui

local circleStroke = Instance.new("UIStroke")
circleStroke.Thickness = 3
circleStroke.Color = Color3.fromRGB(170, 0, 255) -- ‡∏°‡πà‡∏ß‡∏á‡∏ô‡∏µ‡∏≠‡∏≠‡∏ô
circleStroke.Parent = circle

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = circle

local aspect = Instance.new("UIAspectRatioConstraint")
aspect.AspectRatio = 1
aspect.DominantAxis = Enum.DominantAxis.Height
aspect.Parent = circle

--// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏´‡∏•‡∏±‡∏Å
local radius = circleSize / 2
local currentTween = nil
local tweenDuration = 0.10 -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏∏‡πà‡∏°‡∏ô‡∏ß‡∏•‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πá‡∏á
local updateInterval = 0.01
local accumulatedTime = 0
local lockEnabled = false -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏¥‡∏î‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤
local teamCheckEnabled = true -- ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡∏°‡πÇ‡∏î‡∏¢‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô

--// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡∏°
local function IsEnemy(player)
    if not teamCheckEnabled then
        return true -- ‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡∏° ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π
    end
    
    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡∏°‡∏°‡∏µ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if not game:GetService("Teams"):GetChildren() or #game:GetService("Teams"):GetChildren() == 0 then
        return true -- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏µ‡∏°‡πÉ‡∏ô‡πÄ‡∏Å‡∏° ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π
    end
    
    local localTeam = LocalPlayer.Team
    local targetTeam = player.Team
    
    -- ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏µ‡∏° ‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡∏µ‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô = ‡πÄ‡∏õ‡πá‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π
    if not localTeam or not targetTeam or localTeam ~= targetTeam then
        return true
    end
    
    return false -- ‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏µ‡∏°‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
end

--// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡πá‡∏≠‡∏Å‡∏´‡∏±‡∏ß
local function LockToHead(targetHead)
	if not targetHead then return end
	local camPos = Camera.CFrame.Position
	local targetPos = targetHead.Position

	local goalCFrame = CFrame.new(camPos, targetPos)

	if currentTween then
		currentTween:Cancel()
	end

	local tweenInfo = TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	currentTween = TweenService:Create(Camera, tweenInfo, {CFrame = goalCFrame})
	currentTween:Play()
end

--// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏ô‡∏ß‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
local function GetClosestTarget()
	local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
	local closestPlayer = nil
	local shortestDistance = radius

	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
			-- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡∏°‡∏Å‡πà‡∏≠‡∏ô
			if IsEnemy(player) then
				local head = player.Character.Head
				local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
				if onScreen then
					local head2D = Vector2.new(headPos.X, headPos.Y)
					local distance = (head2D - screenCenter).Magnitude
					if distance <= radius and distance < shortestDistance then
						shortestDistance = distance
						closestPlayer = player
					end
				end
			end
		end
	end

	return closestPlayer
end

--// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°
local function SetCircleSize(sizePx)
	radius = sizePx / 2
	circle.Size = UDim2.fromOffset(sizePx, sizePx)
end

--// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î AimLock
local function ToggleAimLock(state)
	lockEnabled = state
	circle.Visible = state
	if not state and currentTween then
		currentTween:Cancel()
		currentTween = nil
	end
end

--// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Team Check
local function ToggleTeamCheck(state)
	teamCheckEnabled = state
end

--// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏° (‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏£‡∏¥‡∏á‡∏ï‡∏≤‡∏° updateInterval)
RunService.RenderStepped:Connect(function(deltaTime)
	if not lockEnabled then return end

	accumulatedTime += deltaTime
	if accumulatedTime >= updateInterval then
		accumulatedTime = 0
		local target = GetClosestTarget()
		if target and target.Character and target.Character:FindFirstChild("Head") then
			LockToHead(target.Character.Head)
		end
	end
end)

--// UI Framework: PlayerTab toggle ‡πÅ‡∏•‡∏∞ slider (‡∏™‡∏°‡∏°‡∏ï‡∏¥ PlayerTab ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß)
PlayerTab:Toggle({
	Title = "‡∏•‡πá‡∏≠‡∏Å‡∏´‡∏±‡∏ß(‡∏°‡∏±‡∏ô‡∏Å‡∏≤‡∏Å‡∏≠‡∏¢‡∏π‡πà)",
	Value = false,
	Callback = function(value)
		ToggleAimLock(value)
	end
})

PlayerTab:Slider({
	Title = "‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏•‡πá‡∏≠‡∏Å",
	Min = 50,
	Max = 400,
	Value = radius * 2,
	Callback = function(val)
		SetCircleSize(val)
	end
})

PlayerTab:Toggle({
	Title = "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡∏° (‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Å‡∏ó‡∏µ‡∏°‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô)",
	Value = teamCheckEnabled,
	Callback = function(value)
		ToggleTeamCheck(value)
	end
})
   local RunService = game:GetService("RunService")
getgenv().Fling = false  -- ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ true/false

local function ToggleFling(state)
    getgenv().Fling = state
end

task.spawn(function()
    while true do
        RunService.Heartbeat:Wait()
        if getgenv().Fling then
            local player = game.Players.LocalPlayer
            local character = player and player.Character
            local root = character and character:FindFirstChild("HumanoidRootPart")
            local humanoid = character and character:FindFirstChildWhichIsA("Humanoid")
            if not (character and root and humanoid) then
                continue
            end

            humanoid.Died:Once(function()
                getgenv().Fling = false
            end)

            for _, v in pairs(character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            local vel = root.Velocity
            local movel = 0.1
            root.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
            RunService.RenderStepped:Wait()
            root.Velocity = vel
            RunService.Stepped:Wait()
            root.Velocity = vel + Vector3.new(0, movel, 0)
            movel = -movel
        end
    end
end)

-- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö PlayerTab UI toggle
PlayerTab:Toggle({
    Title = "‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô(‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ö‡∏≤‡∏á‡πÅ‡∏°‡∏û)",
    Value = false,
    Callback = function(value)
        ToggleFling(value)
    end
})

local API_Bypass = getgenv()
API_Bypass["_CR.DayToDay2044_Fly"] = API_Bypass["_CR.DayToDay2044_Fly"] or false
API_Bypass["_CR.DayToDay2044_Speed"] = API_Bypass["_CR.DayToDay2044_Speed"] or 100

loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\114\97\119\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\83\85\78\82\84\88\50\50\47\87\104\97\116\95\104\97\112\112\101\110\95\100\97\102\97\107\47\114\101\102\115\47\104\101\97\100\115\47\109\97\105\110\47\70\108\121\95\65\80\73"))()

PlayerTab:Toggle({
    Title = "‡∏ö‡∏¥‡∏ô‡πÅ‡∏ö‡∏ö‡∏ö‡∏≤‡∏¢‡∏û‡∏≤‡∏™",
    Value = API_Bypass["_CR.DayToDay2044_Fly"],
    Callback = function(value)
        API_Bypass["_CR.DayToDay2044_Fly"] = value
    end
})

PlayerTab:Slider({
    Title = "‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏¥‡∏ô",
    Min = 1,
    Max = 500,
    Value = API_Bypass["_CR.DayToDay2044_Speed"],
    Callback = function(value)
        API_Bypass["_CR.DayToDay2044_Speed"] = value
    end
})

 
local CreditTab = Window:Tab({Title = "Credits", Icon = "heart"}) do
    CreditTab:Section({Title = "‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏í‡∏ô‡∏≤"})
    CreditTab:Button({
        Title = "üìã Copy Discord Link",
        Desc = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå Discord ‡∏Ç‡∏≠‡∏á ERROR HUB",
        Callback = function()
            setclipboard("https://discord.gg/eZwAXpwAt")
            Window:Notify({Title = "Copied!", Desc = "‡∏•‡∏¥‡∏á‡∏Å‡πå Discord ‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß ‚úÖ", Time = 3})
        end
    })
end

Window:Notify({
    Title = "ERROR HUB",
    Desc = "‚úÖ Loaded successfully!",
    Time = 6
})
